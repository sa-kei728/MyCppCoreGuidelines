# I.1: Make interfaces explicit
インターフェイスを明示せよ

## Reason
正しさ. インターフェイスに記載されていない前提条件は見落とされやすくテストも困難です.

## Example, bad
グローバル(namespace scope)変数(コールモード)を介して関数の動作を制御することは,暗黙の了解であり, 混乱を招く可能性があります.  
例えば, 以下のようになります.  
```
int round(double d)
{
    return (round_up) ? ceil(d) : d;    // don't: "invisible" dependency
}
```
round(7.2)の2つの呼び出しの意味が異なる結果になることは, 呼び出し側には明らかではないでしょう.

## Exception
通常出力と詳細出力, デバッグと最適化など, 一連の操作の詳細を環境変数で制御することがあります.  
非ローカル制御の使用は混乱を招く可能性がありますが, 他の方法では固定されたセマンティクスの実装の詳細のみを制御します. 

## Example, bad
非ローカル変数（errnoなど）を使った報告は簡単に無視できます. 例えば
```
// don't: no test of printf's return value
fprintf(connection, "logging: %d %d %d\n", x, y, s);
```
ロギング出力が出ないように接続が切れたらどうしますか?

## Alternative
例外を発生させます. 例外は無視できません.

## Alternative formulation
非局所的または暗黙的な状態を介してインターフェイス上で情報を渡すことは避けてください.  
非constのメンバ関数は, そのオブジェクトの状態を通して他のメンバ関数に情報を渡すことに注意してください. 

## Alternative formulation
インターフェースは関数または関数のセットでなければなりません.  
関数は関数テンプレート, 関数のセットはクラスまたはクラステンプレートになります. 

## Enforcement
- (単純)関数は, 名前空間のスコープで宣言された変数の値に基づいて制御フローの決定を行うべきではありません.
- (単純)関数は, 名前空間のスコープで宣言された変数に書き込むべきではありません.

### 個人的な所感
流石に自明な内容だと思います.  
要は"前提条件をスコープ外に依存した形で制御するな."ということではないかと.  
2例目もprint出力がされるかどうかを外の状態に依存するので望ましくないでしょう.  
下記のように実装してあればログ出力がされるかどうかはまだ分かりやすいかと思いますが...  
```
// ログレベルに応じて出力するかどうかを判断.
LOGGING(LOG_LEVEL, "%d\n", x);
```
