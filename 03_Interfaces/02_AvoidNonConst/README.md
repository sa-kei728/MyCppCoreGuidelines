# I.2: Avoid non-const global variables
非constのグローバル変数は避けよ

## Reason
非constのグローバル変数は依存関係を隠してしまい, 依存関係が予測不可能な変更を受けてしまいます。

## Example
```
struct Data {
    // ... lots of stuff ...
} data;            // non-const data

void compute()     // don't
{
    // ... use data ...
}

void output()     // don't
{
    // ... use data ...
}
```
他に誰がデータを修正するのか?

## Warning
グローバルオブジェクトの初期化は完全には順序付けられていません.  
グローバルオブジェクトを使用する場合は定数で初期化してください.  
なお, constオブジェクトであっても初期化の順序が不定になる可能性があります.  

## Exception
グローバルオブジェクトはシングルトンよりも優れていることが多い.  

## Note
グローバル定数は便利です.  

## Note
グローバル変数に対するルールは, ネームスペーススコープの変数にも適用されます.  

## Alternative
コピーを避けるためにグローバル(より一般的には名前空間のスコープ)データを使用する場合は,  
データをオブジェクトとしてconstに参照渡しすることを検討してください.  
また, データを何らかのオブジェクトの状態として定義し, 操作をメンバ関数として定義するという解決策もあります.  

## Warning
データ競合に注意してください.  
別のスレッドが呼び出し元を実行している間に, あるスレッドが非ローカルデータ(または参照渡しのデータ)にアクセスできると,  
データ競合が発生する可能性があります. ミュータブルデータへのポインタや参照はすべてデータレースの可能性があります.  
グローバルなポインタや参照を使って, 非constのデータにアクセスしたり, 変更したりすることは,  
非constのグローバル変数の代わりにはなりません.  
なぜなら, 隠れた依存性や潜在的な競合状態の問題を解決できないからです.  

## Note
イミュータブルなデータに競合状態はありえません.  

## Note
ルールは, "使わない"ではなく"避ける"です.  
もちろん, cin, cout, cerrのような(稀な)例外もあります.  

## Enforcement
(単純）名前空間スコープで宣言されたすべての非const変数と, 非constデータへのグローバルなポインタ/参照を報告する.  

### 個人的な所感
自明ではあるが, 非constであればglobal変数バンバン使っていいという話と捉えず,  
なるべく名前空間をちゃんと設定しよう.  
