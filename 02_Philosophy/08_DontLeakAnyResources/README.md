# P.8: Don’t leak any resources
リソースをリークするな

## Reason
ゆっくりとリソースを増やしても, 時間が経てばそのリソースを使い切ってしまいます.  
このことは長時間動作するプログラムでは特に重要ですが責任あるプログラミング行動のためには不可欠な要素です.  

## Example, bad
```
void f(char* name)
{
    FILE* input = fopen(name, "r");
    // ...
    if (something) return;   // bad: if something == true, a file handle is leaked
    // ...
    fclose(input);
}
```
RAIIでより良くなる.
```
void f(char* name)
{
    ifstream input {name};
    // ...
    if (something) return;   // OK: no leak
    // ...
}
```

## Note
リークとは口語的には"掃除されていないもの"を指します.  より重要な分類は"もはやクリーンアップできないもの"です.  
例えば, ヒープ上にオブジェクトを確保した後, その確保したオブジェクトを指す最後のポインタを失うことです.  
このルールは, 長期保存可能なオブジェクト内のアロケーションをプログラムの終了時に返却しなければならないと解釈すべきではありません.  
例えば, プロセスの終了時にファイルのクローズやメモリの解放など,  
システムで保証された後始末に頼ることで, コードを簡素化することができます.  
しかし, 暗黙のうちにクリーンアップを行う抽象化に頼ることも, 同様にシンプルで安全な場合があります.  

## Note
[ライフタイムセーフティープロファイル](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#SS-lifetime)を実施することでリークがなくなります.  
RAIIが提供するリソースセーフと組み合わせると, (ゴミを出さないことで)"ガベージコレクション"の必要性がなくなります.  
これに型と境界のプロファイルを組み合わせればツールで保証された完全な型安全性と資源安全性が得られます.

## Enforcement
- ポインターを見る: ポインタを非所有者（デフォルト）と所有者に分類します. 可能であれば, 所有者を標準的なライブラリ・リソース・ハンドルに置き換えてください(上のExampleのように). あるいは, GSLのownerを使用して所有者をマークする.
- 裸の新規および削除を探す.
- 生のポインタを返す既知のリソース割り当て関数を探す(fopen, malloc, strdupなど).

### 個人的な所感
自明な内容ではあるが, 気にしてないと結構やらかす.  
プロセス終了に頼るのは良いのですが, HWが絡んだ外部ライブラリ任せの処理があるならやめておいたほうが良いです.  
自分で書いた[参考記事](https://zenn.dev/rain_squallman/articles/305db05d1f2ca7d7268a)  

あと, 実験的にしか使わないつもりのコードでメモリリークを気にしないのも悪手.  
なぜなら実験的なコードがそのまま転用されることもあったり, 長時間のデモコードに使われたりするから...
